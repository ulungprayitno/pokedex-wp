{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../../src/dom-query.ts","../../../src/use-clickable.ts","../../../src/use-event-listeners.ts","../../../src/use-force-update.ts","../../../src/use-unmount-effect.ts","../../../src/use-descendant.ts","../../../src/use-controllable.ts","../../../src/use-callback-ref.ts","../../../src/use-tabs.ts","../../../src/tabs.tsx","../../../src/stack.utils.tsx","../../../src/stack.tsx"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","isRightClick","event","isValidElement","element","isContentEditable","tagName","useClickable","props","ref","clickOnEnter","clickOnSpace","tabIndex","onMouseLeave","React","listeners","currentListeners","add","type","el","options","remove","value","useEventListeners","isButton","tabIndexProp","trulyDisabled","isDisabled","handleClick","self","onClick","onDocumentKeyUp","e","isPressed","setIsPressed","handleKeyDown","onKeyDown","shouldClickOnEnter","handleKeyUp","onKeyUp","onDocumentMouseUp","handleMouseDown","preventScroll","onMouseDown","handleMouseUp","onMouseUp","handleMouseOver","onMouseOver","handleMouseLeave","mergeRefs","htmlRef","node","setIsButton","undefined","disabled","role","dataAttr","useForceUpdate","fn","unloadingRef","deps","setCount","count","useDescendant","index","focusable","forceUpdate","descendants","useSafeLayoutEffect","register","unregister","indexProp","descendant","useDescendants","useState","useCallback","rest","setDescendants","prevDescendants","item","Boolean","Node","newItem","useMemo","useControllableState","handleChange","args","useCallbackRef","onChange","isControlled","valueProp","updateValue","next","nextValue","runIfFn","setValue","createContext","name","errorMessage","makeTabId","id","makeTabPanelId","Tabs","forwardRef","styles","useMultiStyleConfig","omitThemingProps","className","orientation","defaultIndex","defaultValue","isUndefined","setFocusedIndex","enabledDomContext","domContext","useId","selectedIndex","focusedIndex","setSelectedIndex","isManual","isLazy","htmlProps","useTabs","context","rootProps","omit","cx","__css","root","Tab","useStyles","tabProps","isFocusable","useTabsContext","enabledIndex","current","isSelected","clickableProps","callAllHandlers","onFocus","useTab","tabStyles","outline","display","alignItems","justifyContent","TabList","tablistProps","setIndex","tab","nextTab","prevTab","isHorizontal","isVertical","action","ArrowRight","ArrowLeft","ArrowDown","ArrowUp","Home","End","normalizeEventKey","useTabList","tablistStyles","TabPanel","panelProps","children","hidden","useTabPanel","tabpanel","TabPanels","panelsProps","getValidChildren","useTabPanels","width","TabIndicator","indicatorStyle","left","top","height","tabRect","setRect","requestAnimationFrame","setHasMeasured","cancelAnimationFrame","position","transition","hasMeasured","useTabIndicator","style","indicator","selector","StackItem","flex","minWidth","Stack","direction","spacing","shouldWrapChildren","isInline","directionProp","directionStyles","column","marginTop","marginStart","row","marginBottom","marginEnd","flexDirection","mapResponsive","getStackStyles","dividerStyle","dividerStyles","my","mx","borderLeftWidth","borderBottomWidth","getDividerStyles","hasDivider","shouldUseChildren","validChildren","clones","isLast","_child","_divider","_className","flexWrap","HStack","align","VStack"],"mappings":"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","file":"static/js/4.899f6e38.chunk.js","sourcesContent":["import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { isFocusable, isTabbable, isHTMLElement } from \"./tabbable\"\n\nconst focusableElList = [\n  \"input:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\",\n  \"embed\",\n  \"iframe\",\n  \"object\",\n  \"a[href]\",\n  \"area[href]\",\n  \"button:not([disabled])\",\n  \"[tabindex]\",\n  \"audio[controls]\",\n  \"video[controls]\",\n  \"*[tabindex]:not([aria-disabled])\",\n  \"*[contenteditable]\",\n]\n\nconst focusableElSelector = focusableElList.join()\n\nexport const isRightClick = <E extends MouseEvent | React.MouseEvent>(\n  event: E,\n) => event.button !== 0\n\nexport function getAllFocusable<T extends HTMLElement>(container: T) {\n  const focusableEls = Array.from(\n    container.querySelectorAll<T>(focusableElSelector),\n  )\n  focusableEls.unshift(container)\n  return focusableEls\n    .filter(isFocusable)\n    .filter((el) => window.getComputedStyle(el).display !== \"none\")\n}\n\nexport function getFirstFocusable<T extends HTMLElement>(container: T) {\n  const allFocusable = getAllFocusable(container)\n  return allFocusable.length ? allFocusable[0] : null\n}\n\nexport function getAllTabbable<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n) {\n  const allFocusable = Array.from(\n    container.querySelectorAll<T>(focusableElSelector),\n  )\n  const allTabbable = allFocusable.filter(isTabbable)\n\n  if (isTabbable(container)) {\n    allTabbable.unshift(container)\n  }\n\n  if (!allTabbable.length && fallbackToFocusable) {\n    return allFocusable\n  }\n  return allTabbable\n}\n\nexport function getFirstTabbableIn<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n): T | null {\n  const [first] = getAllTabbable(container, fallbackToFocusable)\n  return first || null\n}\n\nexport function getLastTabbableIn<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n): T | null {\n  const allTabbable = getAllTabbable(container, fallbackToFocusable)\n  return allTabbable[allTabbable.length - 1] || null\n}\n\nexport function getNextTabbable<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n): T | null {\n  const allFocusable = getAllFocusable(container)\n  const index = allFocusable.indexOf(document.activeElement as T)\n  const slice = allFocusable.slice(index + 1)\n  return (\n    slice.find(isTabbable) ||\n    allFocusable.find(isTabbable) ||\n    (fallbackToFocusable ? slice[0] : null)\n  )\n}\n\nexport function getPreviousTabbable<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n): T | null {\n  const allFocusable = getAllFocusable(container).reverse()\n  const index = allFocusable.indexOf(document.activeElement as T)\n  const slice = allFocusable.slice(index + 1)\n  return (\n    slice.find(isTabbable) ||\n    allFocusable.find(isTabbable) ||\n    (fallbackToFocusable ? slice[0] : null)\n  )\n}\n\nexport function focusNextTabbable<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n) {\n  const nextTabbable = getNextTabbable(container, fallbackToFocusable)\n  if (nextTabbable && isHTMLElement(nextTabbable)) {\n    nextTabbable.focus()\n  }\n}\n\nexport function focusPreviousTabbable<T extends HTMLElement>(\n  container: T,\n  fallbackToFocusable?: boolean,\n) {\n  const previousTabbable = getPreviousTabbable(container, fallbackToFocusable)\n  if (previousTabbable && isHTMLElement(previousTabbable)) {\n    previousTabbable.focus()\n  }\n}\n\nfunction matches(element: Element, selectors: string): boolean {\n  if (\"matches\" in element) return element.matches(selectors)\n  if (\"msMatchesSelector\" in element)\n    return (element as any).msMatchesSelector(selectors)\n  return (element as any).webkitMatchesSelector(selectors)\n}\n\nexport function closest<T extends HTMLElement>(element: T, selectors: string) {\n  if (\"closest\" in element) return element.closest(selectors)\n  do {\n    if (matches(element, selectors)) return element\n    element = (element.parentElement || element.parentNode) as any\n  } while (element !== null && element.nodeType === 1)\n  return null\n}\n","import { dataAttr, isRightClick, mergeRefs } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport { useEventListeners } from \"./use-event-listeners\"\n\nexport interface UseClickableProps extends React.HTMLAttributes<HTMLElement> {\n  /**\n   * If `true`, the element will be disabled.\n   * It will set the `disabled` HTML attribute\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and isDisabled, the element will\n   * have only `aria-disabled` set to `true`\n   */\n  isFocusable?: boolean\n  /**\n   * Whether or not trigger click on pressing `Enter`.\n   */\n  clickOnEnter?: boolean\n  /**\n   * Whether or not trigger click on pressing `Space`.\n   */\n  clickOnSpace?: boolean\n  /**\n   * The ref for the element\n   */\n  ref?: React.Ref<HTMLElement>\n}\n\nfunction isValidElement(event: KeyboardEvent): boolean {\n  const element = event.target as HTMLElement\n  const { tagName, isContentEditable } = element\n  return (\n    tagName !== \"INPUT\" && tagName !== \"TEXTAREA\" && isContentEditable !== true\n  )\n}\n\n/**\n * useClickable implements all the interactions of a native `button`\n * component with support for making it focusable even if it is disabled.\n *\n * It can be used with both native button elements or other elements (like `div`).\n */\nexport function useClickable(props: UseClickableProps = {}) {\n  const {\n    ref: htmlRef,\n    isDisabled,\n    isFocusable,\n    clickOnEnter = true,\n    clickOnSpace = true,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onKeyDown,\n    onKeyUp,\n    tabIndex: tabIndexProp,\n    onMouseOver,\n    onMouseLeave,\n    ...htmlProps\n  } = props\n  /**\n   * We'll use this to track if the element is a button element\n   */\n  const [isButton, setIsButton] = React.useState(true)\n\n  /**\n   * For custom button implementation, we'll use this to track when\n   * we mouse down on the button, to enable use style its \":active\" style\n   */\n  const [isPressed, setIsPressed] = React.useState(false)\n\n  const listeners = useEventListeners()\n\n  /**\n   * The ref callback that fires as soon as the dom node is ready\n   */\n  const refCallback = (node: any) => {\n    if (!node) return\n    if (node.tagName !== \"BUTTON\") {\n      setIsButton(false)\n    }\n  }\n\n  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0\n  const trulyDisabled = isDisabled && !isFocusable\n\n  const handleClick = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      if (isDisabled) {\n        event.stopPropagation()\n        event.preventDefault()\n        return\n      }\n\n      const self = event.currentTarget as HTMLElement\n      self.focus()\n      onClick?.(event)\n    },\n    [isDisabled, onClick],\n  )\n\n  const onDocumentKeyUp = React.useCallback(\n    (e: KeyboardEvent) => {\n      if (isPressed && isValidElement(e)) {\n        e.preventDefault()\n        e.stopPropagation()\n\n        setIsPressed(false)\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        listeners.remove(document, \"keyup\", onDocumentKeyUp, false)\n      }\n    },\n    [isPressed, listeners],\n  )\n\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLElement>) => {\n      onKeyDown?.(event)\n\n      if (isDisabled || event.defaultPrevented || event.metaKey) {\n        return\n      }\n\n      if (!isValidElement(event.nativeEvent) || isButton) return\n\n      const shouldClickOnEnter = clickOnEnter && event.key === \"Enter\"\n      const shouldClickOnSpace = clickOnSpace && event.key === \" \"\n\n      if (shouldClickOnSpace) {\n        event.preventDefault()\n        setIsPressed(true)\n      }\n\n      if (shouldClickOnEnter) {\n        event.preventDefault()\n        const self = event.currentTarget as HTMLElement\n        self.click()\n      }\n\n      listeners.add(document, \"keyup\", onDocumentKeyUp, false)\n    },\n    [\n      isDisabled,\n      isButton,\n      onKeyDown,\n      clickOnEnter,\n      clickOnSpace,\n      listeners,\n      onDocumentKeyUp,\n    ],\n  )\n\n  const handleKeyUp = React.useCallback(\n    (event: React.KeyboardEvent<HTMLElement>) => {\n      onKeyUp?.(event)\n\n      if (isDisabled || event.defaultPrevented || event.metaKey) return\n\n      if (!isValidElement(event.nativeEvent) || isButton) return\n\n      const shouldClickOnSpace = clickOnSpace && event.key === \" \"\n\n      if (shouldClickOnSpace) {\n        event.preventDefault()\n        setIsPressed(false)\n\n        const self = event.currentTarget as HTMLElement\n        self.click()\n      }\n    },\n    [clickOnSpace, isButton, isDisabled, onKeyUp],\n  )\n\n  const onDocumentMouseUp = React.useCallback(\n    (event: MouseEvent) => {\n      if (event.button !== 0) return\n      setIsPressed(false)\n      listeners.remove(document, \"mouseup\", onDocumentMouseUp, false)\n    },\n    [listeners],\n  )\n\n  const handleMouseDown = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      if (isRightClick(event)) return\n\n      if (isDisabled) {\n        event.stopPropagation()\n        event.preventDefault()\n        return\n      }\n\n      if (!isButton) {\n        setIsPressed(true)\n      }\n\n      const target = event.currentTarget as HTMLElement\n      target.focus({ preventScroll: true })\n\n      listeners.add(document, \"mouseup\", onDocumentMouseUp, false)\n\n      onMouseDown?.(event)\n    },\n    [isDisabled, isButton, onMouseDown, listeners, onDocumentMouseUp],\n  )\n\n  const handleMouseUp = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      if (isRightClick(event)) return\n\n      if (!isButton) {\n        setIsPressed(false)\n      }\n\n      onMouseUp?.(event)\n    },\n    [onMouseUp, isButton],\n  )\n\n  const handleMouseOver = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      if (isDisabled) {\n        event.preventDefault()\n        return\n      }\n\n      onMouseOver?.(event)\n    },\n    [isDisabled, onMouseOver],\n  )\n\n  const handleMouseLeave = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      if (isPressed) {\n        event.preventDefault()\n        setIsPressed(false)\n      }\n      onMouseLeave?.(event)\n    },\n    [isPressed, onMouseLeave],\n  )\n\n  const ref = mergeRefs(htmlRef, refCallback)\n\n  if (isButton) {\n    return {\n      ...htmlProps,\n      ref,\n      type: \"button\" as React.ButtonHTMLAttributes<any>[\"type\"],\n      \"aria-disabled\": trulyDisabled ? undefined : isDisabled,\n      disabled: trulyDisabled,\n      onClick: handleClick,\n      onMouseDown,\n      onMouseUp,\n      onKeyUp,\n      onKeyDown,\n      onMouseOver,\n      onMouseLeave,\n    }\n  }\n\n  return {\n    ...htmlProps,\n    ref,\n    role: \"button\",\n    \"data-active\": dataAttr(isPressed),\n    \"aria-disabled\": isDisabled ? (\"true\" as const) : undefined,\n    tabIndex: trulyDisabled ? undefined : tabIndex,\n    onClick: handleClick,\n    onMouseDown: handleMouseDown,\n    onMouseUp: handleMouseUp,\n    onKeyUp: handleKeyUp,\n    onKeyDown: handleKeyDown,\n    onMouseOver: handleMouseOver,\n    onMouseLeave: handleMouseLeave,\n  }\n}\n\nexport type UseClickableReturn = ReturnType<typeof useClickable>\n","import * as React from \"react\"\n\ninterface EventListeners {\n  add<K extends keyof DocumentEventMap>(\n    el: EventTarget,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  add(\n    el: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  remove<K extends keyof DocumentEventMap>(\n    el: EventTarget,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void\n  remove(\n    el: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n}\n\nexport function useEventListeners(): EventListeners {\n  const listeners = React.useRef(new Map())\n  const currentListeners = listeners.current\n\n  const add = React.useCallback((el, type, listener, options) => {\n    listeners.current.set(listener, { type, el, options })\n    el.addEventListener(type, listener, options)\n  }, [])\n\n  const remove = React.useCallback((el, type, listener, options) => {\n    el.removeEventListener(type, listener, options)\n    listeners.current.delete(listener)\n  }, [])\n\n  React.useEffect(\n    () => () => {\n      currentListeners.forEach((value, key) => {\n        remove(value.el, value.type, key, value.options)\n      })\n    },\n    [remove, currentListeners],\n  )\n\n  return { add, remove }\n}\n","import * as React from \"react\"\nimport { useUnmountEffect } from \"./use-unmount-effect\"\n\nexport function useForceUpdate() {\n  const unloadingRef = React.useRef(false)\n  const [count, setCount] = React.useState(0)\n\n  useUnmountEffect(() => {\n    unloadingRef.current = true\n  })\n\n  return React.useCallback(() => {\n    if (!unloadingRef.current) {\n      setCount(count + 1)\n    }\n  }, [count])\n}\n","import * as React from \"react\"\n\nexport function useUnmountEffect(fn: () => void, deps: any[] = []) {\n  return React.useEffect(\n    () => () => fn(),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps,\n  )\n}\n","import { useCallback, useMemo, useState } from \"react\"\nimport { useSafeLayoutEffect, useForceUpdate } from \"@chakra-ui/hooks\"\n\nexport type Descendant<T extends HTMLElement, P = {}> = P & {\n  element: T | null\n  index?: number\n  disabled?: boolean\n  focusable?: boolean\n}\n\nexport interface DescendantContext<T extends HTMLElement, P = {}> {\n  descendants: Descendant<T, P>[]\n  register: (descendant: Descendant<T, P>) => void\n  unregister: (element: T) => void\n}\n\nexport type UseDescendantProps<T extends HTMLElement, P> = {\n  context: DescendantContext<T, P>\n} & Descendant<T, P>\n\nexport function useDescendant<T extends HTMLElement, P>(\n  props: UseDescendantProps<T, P>,\n) {\n  const {\n    context,\n    element,\n    index: indexProp,\n    disabled,\n    focusable,\n    ...rest\n  } = props\n\n  const forceUpdate = useForceUpdate()\n  const { register, unregister, descendants } = context\n\n  useSafeLayoutEffect(() => {\n    if (!element) {\n      forceUpdate()\n    }\n\n    /**\n     * Don't register this descendant if it is disabled and not focusable\n     */\n    if (disabled && !focusable) return undefined\n\n    /**\n     * else, register the descendant\n     */\n    register({ element, disabled, focusable, ...rest } as any)\n\n    /**\n     * when it unmounts, unregister the descendant\n     */\n    return () => {\n      if (element) {\n        unregister(element)\n      }\n    }\n    // eslint-disable-next-line\n  }, [element, disabled, focusable, ...Object.values(rest)])\n\n  const index =\n    indexProp ??\n    descendants.findIndex((descendant) => descendant.element === element)\n\n  return index\n}\n\nexport function useDescendants<T extends HTMLElement, P>() {\n  const [descendants, setDescendants] = useState<Descendant<T, P>[]>([])\n\n  const register = useCallback(({ element, ...rest }: Descendant<T, P>) => {\n    if (!element) return\n\n    // @ts-ignore\n    setDescendants((prevDescendants) => {\n      if (prevDescendants.find((item) => item.element === element) == null) {\n        const index = prevDescendants.findIndex((item) => {\n          if (!item.element || !element) return false\n\n          return Boolean(\n            item.element.compareDocumentPosition(element) &\n              Node.DOCUMENT_POSITION_PRECEDING,\n          )\n        })\n\n        const newItem = { element, ...rest }\n\n        if (index === -1) {\n          return [...prevDescendants, newItem]\n        }\n        return [\n          ...prevDescendants.slice(0, index),\n          newItem,\n          ...prevDescendants.slice(index),\n        ]\n      }\n      return prevDescendants\n    })\n  }, [])\n\n  const unregister = useCallback((element: T) => {\n    if (!element) return\n    setDescendants((descendants) =>\n      descendants.filter((descendant) => element !== descendant.element),\n    )\n  }, [])\n\n  const context = useMemo(() => ({ descendants, register, unregister }), [\n    descendants,\n    register,\n    unregister,\n  ])\n\n  return context\n}\n","import { runIfFn } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport { useCallbackRef } from \"./use-callback-ref\"\n\nexport function useControllableProp<T>(prop: T | undefined, state: T) {\n  const isControlled = prop !== undefined\n  const value = isControlled && typeof prop !== \"undefined\" ? prop : state\n  return [isControlled, value] as const\n}\n\nexport interface UseControllableStateProps<T> {\n  /**\n   * The value to used in controlled mode\n   */\n  value?: T\n  /**\n   * The initial value to be used, in uncontrolled mode\n   */\n  defaultValue?: T | (() => T)\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?: (value: T) => void\n  /**\n   * The component name (for warnings)\n   */\n  name?: string\n}\n\n/**\n * React hook for using controlling component state.\n * @param props\n */\nexport function useControllableState<T>(props: UseControllableStateProps<T>) {\n  const { value: valueProp, defaultValue, onChange } = props\n  const handleChange = useCallbackRef(onChange)\n\n  const [valueState, setValue] = React.useState(defaultValue as T)\n  const isControlled = valueProp !== undefined\n\n  const value = isControlled ? (valueProp as T) : valueState\n\n  const updateValue = React.useCallback(\n    (next: React.SetStateAction<T>) => {\n      const nextValue = runIfFn(next, value)\n      if (!isControlled) {\n        setValue(nextValue)\n      }\n      handleChange(nextValue)\n    },\n    [isControlled, handleChange, value],\n  )\n\n  return [value, updateValue] as [T, React.Dispatch<React.SetStateAction<T>>]\n}\n","import * as React from \"react\"\nimport { useSafeLayoutEffect } from \"./use-safe-layout-effect\"\n\n/**\n * React hook to persist any value between renders,\n * but keeps it up-to-date if it changes.\n *\n * @param value the value or function to persist\n */\nexport function useCallbackRef<T extends (...args: any[]) => any>(\n  fn: T | undefined,\n): T {\n  const ref = React.useRef(fn)\n\n  useSafeLayoutEffect(() => {\n    ref.current = fn\n  })\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(((...args) => ref.current?.(...args)) as T, [])\n}\n","import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useId,\n  useSafeLayoutEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  callAllHandlers,\n  createContext,\n  Dict,\n  EventKeyMap,\n  getValidChildren,\n  isUndefined,\n  mergeRefs,\n  normalizeEventKey,\n} from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance 🚀:\n   * If `true`, the TabPanel rendering will be deferred\n   * until it is open.\n   */\n  isLazy?: boolean\n}\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    orientation = \"horizontal\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = React.useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  React.useEffect(() => {\n    if (!isUndefined(index)) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   *\n   * This manager is used to store only the tab nodes that are not disabled, and focusable.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\" and \"Tab 3\", since `Tab 2` is disabled\n   */\n  const enabledDomContext = useDescendants()\n\n  /**\n   * This manager is used to store all tab nodes whether disabled or not.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\", \"Tab 2\" \"Tab 3\".\n   *\n   * We need this for correct indexing of tabs in event a tab is disabled\n   */\n  const domContext = useDescendants()\n\n  /**\n   * generate a unique id or use user-provided id for\n   * the tabs widget\n   */\n  const id = useId(props.id, `tabs`)\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    orientation,\n    enabledDomContext,\n    domContext,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<ReturnType<typeof useTabs>, \"htmlProps\">\n\nconst [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport { TabsProvider, useTabsContext }\n\ntype Child = React.ReactElement<any>\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    orientation,\n    enabledDomContext,\n  } = useTabsContext()\n\n  const count = enabledDomContext.descendants.length\n\n  /**\n   * Function to update the selected tab index\n   */\n  const setIndex = React.useCallback(\n    (index: number) => {\n      const tab = enabledDomContext.descendants[index]\n      if (tab?.element) {\n        tab.element.focus()\n        setFocusedIndex(index)\n      }\n    },\n    [enabledDomContext.descendants, setFocusedIndex],\n  )\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => setIndex((focusedIndex + 1) % count)\n      const prevTab = () => setIndex((focusedIndex - 1 + count) % count)\n      const firstTab = () => setIndex(0)\n      const lastTab = () => setIndex(count - 1)\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => isHorizontal && nextTab(),\n        ArrowLeft: () => isHorizontal && prevTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [count, focusedIndex, orientation, setIndex],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  id?: string\n  isSelected?: boolean\n  panelId?: string\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   */\n  isDisabled?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled, isFocusable, ...htmlProps } = props\n\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    enabledDomContext,\n    domContext,\n    selectedIndex,\n  } = useTabsContext()\n\n  const ref = React.useRef<HTMLElement>(null)\n\n  /**\n   * Think of `useDescendant` as the function that registers tab node\n   * to the `enabledDomContext`, and returns its index.\n   *\n   * Tab is registered if it is enabled or focusable\n   */\n  const enabledIndex = useDescendant({\n    disabled: Boolean(isDisabled),\n    focusable: Boolean(isFocusable),\n    context: enabledDomContext,\n    element: ref.current,\n  })\n\n  /**\n   * Registers all tabs (whether disabled or not)\n   */\n  const index = useDescendant({\n    context: domContext,\n    element: ref.current,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setFocusedIndex(enabledIndex)\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(ref, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    React.cloneElement(child as Child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      /**\n       * Refers to the associated tab element, and also provides an accessible name to the tab panel.\n       */\n      \"aria-labelledby\": makeTabId(id, index),\n    }),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Dict) {\n  const { isSelected, id, children, ...htmlProps } = props\n  const { isLazy } = useTabsContext()\n\n  return {\n    /**\n     * Puts the tabpanel in the page `Tab` sequence.\n     */\n    tabIndex: 0,\n    ...htmlProps,\n    children: !isLazy || isSelected ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n\n  const { selectedIndex, orientation, domContext } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = React.useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = React.useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (isUndefined(selectedIndex)) return undefined\n\n    const tab = domContext.descendants[selectedIndex]\n    const tabRect = tab?.element?.getBoundingClientRect()\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal && tabRect) {\n      const { left, width } = tabRect\n      setRect({ left, width })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical && tabRect) {\n      const { top, height } = tabRect\n      setRect({ top, height })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, domContext.descendants])\n\n  return {\n    position: \"absolute\",\n    transition: hasMeasured ? \"all 200ms cubic-bezier(0, 0, 0.2, 1)\" : \"none\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n","import {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  StylesProvider,\n  SystemStyleObject,\n  ThemingProps,\n  useMultiStyleConfig,\n  useStyles,\n  HTMLChakraProps,\n} from \"@chakra-ui/system\"\nimport { cx, omit, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport {\n  TabsProvider,\n  useTab,\n  useTabIndicator,\n  useTabList,\n  UseTabListProps,\n  UseTabOptions,\n  useTabPanel,\n  useTabPanels,\n  useTabs,\n  UseTabsProps,\n} from \"./use-tabs\"\n\ninterface TabsOptions {\n  /**\n   * If `true`, tabs will stretch to width of the tablist.\n   */\n  isFitted?: boolean\n  /**\n   * The alignment of the tabs\n   */\n  align?: \"start\" | \"end\" | \"center\"\n}\n\nexport interface TabsProps\n  extends UseTabsProps,\n    ThemingProps<\"Tabs\">,\n    Omit<HTMLChakraProps<\"div\">, \"onChange\">,\n    TabsOptions {\n  children: React.ReactNode\n}\n\n/**\n * Tabs\n *\n * Provides context and logic for all tabs components. It doesn't render\n * any DOM node.\n */\nexport const Tabs = forwardRef<TabsProps, \"div\">((props, ref) => {\n  const styles = useMultiStyleConfig(\"Tabs\", props)\n  const { children, className, ...rest } = omitThemingProps(props)\n\n  const { htmlProps, ...ctx } = useTabs(rest)\n  const context = React.useMemo(() => ctx, [ctx])\n\n  const rootProps = omit(htmlProps as any, [\"isFitted\"])\n\n  return (\n    <TabsProvider value={context}>\n      <StylesProvider value={styles}>\n        <chakra.div\n          className={cx(\"chakra-tabs\", className)}\n          ref={ref}\n          {...rootProps}\n          __css={styles.root}\n        >\n          {children}\n        </chakra.div>\n      </StylesProvider>\n    </TabsProvider>\n  )\n})\n\nif (__DEV__) {\n  Tabs.displayName = \"Tabs\"\n}\n\nexport interface TabProps extends UseTabOptions, HTMLChakraProps<\"button\"> {}\n\n/**\n * Tab button used to activate a specific tab panel. It renders a `button`,\n * and is responsible for automatic and manual selection modes.\n */\nexport const Tab = forwardRef<TabProps, \"button\">((props, ref) => {\n  const styles = useStyles()\n  const tabProps = useTab({ ...props, ref })\n\n  const tabStyles: SystemStyleObject = {\n    outline: \"0\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    ...styles.tab,\n  }\n\n  return (\n    <chakra.button\n      {...tabProps}\n      className={cx(\"chakra-tabs__tab\", props.className)}\n      __css={tabStyles}\n    />\n  )\n})\n\nif (__DEV__) {\n  Tab.displayName = \"Tab\"\n}\n\nexport interface TabListProps\n  extends UseTabListProps,\n    Omit<HTMLChakraProps<\"div\">, \"onKeyDown\" | \"ref\"> {}\n\n/**\n * TabList is used to manage a list of tab buttons. It renders a `div` by default,\n * and is responsible the keyboard interaction between tabs.\n */\nexport const TabList = forwardRef<TabListProps, \"div\">((props, ref) => {\n  const tablistProps = useTabList({ ...props, ref })\n\n  const styles = useStyles()\n\n  const tablistStyles: SystemStyleObject = {\n    display: \"flex\",\n    ...styles.tablist,\n  }\n\n  return (\n    <chakra.div\n      {...tablistProps}\n      className={cx(\"chakra-tabs__tablist\", props.className)}\n      __css={tablistStyles}\n    />\n  )\n})\n\nif (__DEV__) {\n  TabList.displayName = \"TabList\"\n}\n\nexport interface TabPanelProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * TabPanel\n * Used to render the content for a specific tab.\n */\nexport const TabPanel = forwardRef<TabPanelProps, \"div\">((props, ref) => {\n  const panelProps = useTabPanel({ ...props, ref })\n  const styles = useStyles()\n\n  return (\n    <chakra.div\n      outline=\"0\"\n      {...panelProps}\n      className={cx(\"chakra-tabs__tab-panel\", props.className)}\n      __css={styles.tabpanel}\n    />\n  )\n})\n\nif (__DEV__) {\n  TabPanel.displayName = \"TabPanel\"\n}\n\nexport interface TabPanelsProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * TabPanel\n *\n * Used to manage the rendering of multiple tab panels. It uses\n * `cloneElement` to hide/show tab panels.\n *\n * It renders a `div` by default.\n */\nexport const TabPanels = forwardRef<TabPanelsProps, \"div\">((props, ref) => {\n  const panelsProps = useTabPanels(props)\n  return (\n    <chakra.div\n      {...panelsProps}\n      width=\"100%\"\n      ref={ref}\n      className={cx(\"chakra-tabs__tab-panels\", props.className)}\n    />\n  )\n})\n\nif (__DEV__) {\n  TabPanels.displayName = \"TabPanels\"\n}\n\nexport interface TabIndicatorProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * TabIndicator\n *\n * Used to render an active tab indicator that animates between\n * selected tabs.\n */\nexport const TabIndicator = forwardRef<TabIndicatorProps, \"div\">(\n  (props, ref) => {\n    const indicatorStyle = useTabIndicator()\n    const style = {\n      ...props.style,\n      ...indicatorStyle,\n    }\n\n    const styles = useStyles()\n\n    return (\n      <chakra.div\n        ref={ref}\n        {...props}\n        className={cx(\"chakra-tabs__tab-indicator\", props.className)}\n        style={style}\n        __css={styles.indicator}\n      />\n    )\n  },\n)\n\nif (__DEV__) {\n  TabIndicator.displayName = \"TabIndicator\"\n}\n","import { ResponsiveValue, SystemProps } from \"@chakra-ui/system\"\nimport { mapResponsive } from \"@chakra-ui/utils\"\n\nexport type StackDirection = ResponsiveValue<\n  \"row\" | \"column\" | \"row-reverse\" | \"column-reverse\"\n>\n\n/**\n * If we ever run into SSR issues with this, check this post to find a fix for it:\n * @see https://medium.com/@emmenko/patching-lobotomized-owl-selector-for-emotion-ssr-5a582a3c424c\n */\nexport const selector = \"& > *:not(style) ~ *:not(style)\"\n\ninterface Options {\n  spacing: SystemProps[\"margin\"]\n  direction: StackDirection\n}\n\nexport function getStackStyles(options: Options) {\n  const { spacing, direction } = options\n\n  const directionStyles = {\n    column: { marginTop: spacing, marginStart: 0 },\n    row: { marginStart: spacing, marginTop: 0 },\n    \"column-reverse\": { marginBottom: spacing, marginEnd: 0 },\n    \"row-reverse\": { marginEnd: spacing, marginBottom: 0 },\n  }\n\n  return {\n    flexDirection: direction,\n    [selector]: mapResponsive(direction, (value) => directionStyles[value]),\n  }\n}\n\nexport function getDividerStyles(options: Options) {\n  const { spacing, direction } = options\n\n  const dividerStyles = {\n    column: {\n      my: spacing,\n      mx: 0,\n      borderLeftWidth: 0,\n      borderBottomWidth: \"1px\",\n    },\n    \"column-reverse\": {\n      my: spacing,\n      mx: 0,\n      borderLeftWidth: 0,\n      borderBottomWidth: \"1px\",\n    },\n    row: {\n      mx: spacing,\n      my: 0,\n      borderLeftWidth: \"1px\",\n      borderBottomWidth: 0,\n    },\n    \"row-reverse\": {\n      mx: spacing,\n      my: 0,\n      borderLeftWidth: \"1px\",\n      borderBottomWidth: 0,\n    },\n  }\n\n  return {\n    \"&\": mapResponsive(direction, (value) => dividerStyles[value]),\n  }\n}\n","import {\n  chakra,\n  ChakraComponent,\n  forwardRef,\n  HTMLChakraProps,\n  SystemProps,\n} from \"@chakra-ui/system\"\nimport { cx, getValidChildren, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport type { StackDirection } from \"./stack.utils\"\nimport { getDividerStyles, getStackStyles, selector } from \"./stack.utils\"\n\nexport type { StackDirection }\n\ninterface StackOptions {\n  /**\n   * Shorthand for `alignItems` style prop\n   * @type SystemProps[\"alignItems\"]\n   */\n  align?: SystemProps[\"alignItems\"]\n  /**\n   * Shorthand for `justifyContent` style prop\n   * @type SystemProps[\"justifyContent\"]\n   */\n  justify?: SystemProps[\"justifyContent\"]\n  /**\n   * Shorthand for `flexWrap` style prop\n   * @type SystemProps[\"flexWrap\"]\n   */\n  wrap?: SystemProps[\"flexWrap\"]\n  /**\n   * The space between each stack item\n   * @type SystemProps[\"margin\"]\n   */\n  spacing?: SystemProps[\"margin\"]\n  /**\n   * The direction to stack the items.\n   */\n  direction?: StackDirection\n  /**\n   * If `true`, each stack item will show a divider\n   * @type React.ReactElement\n   */\n  divider?: React.ReactElement\n  /**\n   * If `true`, the children will be wrapped in a `Box` with\n   * `display: inline-block`, and the `Box` will take the spacing props\n   */\n  shouldWrapChildren?: boolean\n  /**\n   * If `true` the items will be stacked horizontally.\n   */\n  isInline?: boolean\n}\n\nexport interface StackDividerProps extends HTMLChakraProps<\"div\"> {}\n\nexport const StackDivider: ChakraComponent<\"div\"> = (props) => (\n  <chakra.div\n    className=\"chakra-stack__divider\"\n    {...props}\n    __css={{\n      ...props[\"__css\"],\n      borderWidth: 0,\n      alignSelf: \"stretch\",\n      borderColor: \"inherit\",\n      width: \"auto\",\n      height: \"auto\",\n    }}\n  />\n)\n\nexport const StackItem: ChakraComponent<\"div\"> = (props) => (\n  <chakra.div\n    className=\"chakra-stack__item\"\n    {...props}\n    __css={{\n      display: \"inline-block\",\n      flex: \"0 0 auto\",\n      minWidth: 0,\n      ...props[\"__css\"],\n    }}\n  />\n)\n\nexport interface StackProps extends HTMLChakraProps<\"div\">, StackOptions {}\n\n/**\n * Stacks help you easily create flexible and automatically distributed layouts\n *\n * You can stack elements in the horizontal or vertical direction,\n * and apply a space or/and divider between each element.\n *\n * It uses `display: flex` internally and renders a `div`.\n *\n * @see Docs https://chakra-ui.com/docs/layout/stack\n *\n */\nexport const Stack = forwardRef<StackProps, \"div\">((props, ref) => {\n  const {\n    isInline,\n    direction: directionProp,\n    align,\n    justify,\n    spacing = \"0.5rem\",\n    wrap,\n    children,\n    divider,\n    className,\n    shouldWrapChildren,\n    ...rest\n  } = props\n\n  const direction = isInline ? \"row\" : directionProp ?? \"column\"\n\n  const styles = React.useMemo(() => getStackStyles({ direction, spacing }), [\n    direction,\n    spacing,\n  ])\n\n  const dividerStyle = React.useMemo(\n    () => getDividerStyles({ spacing, direction }),\n    [spacing, direction],\n  )\n\n  const hasDivider = !!divider\n  const shouldUseChildren = !shouldWrapChildren && !hasDivider\n\n  const validChildren = getValidChildren(children)\n\n  const clones = shouldUseChildren\n    ? validChildren\n    : validChildren.map((child, index) => {\n        const isLast = index + 1 === validChildren.length\n        const wrappedChild = <StackItem key={index}>{child}</StackItem>\n        const _child = shouldWrapChildren ? wrappedChild : child\n\n        if (!hasDivider) return _child\n\n        const clonedDivider = React.cloneElement(\n          divider as React.ReactElement<any>,\n          { __css: dividerStyle },\n        )\n\n        const _divider = isLast ? null : clonedDivider\n\n        return (\n          <React.Fragment key={index}>\n            {_child}\n            {_divider}\n          </React.Fragment>\n        )\n      })\n\n  const _className = cx(\"chakra-stack\", className)\n\n  return (\n    <chakra.div\n      ref={ref}\n      display=\"flex\"\n      alignItems={align}\n      justifyContent={justify}\n      flexDirection={styles.flexDirection}\n      flexWrap={wrap}\n      className={_className}\n      __css={hasDivider ? {} : { [selector]: styles[selector] }}\n      {...rest}\n    >\n      {clones}\n    </chakra.div>\n  )\n})\n\nif (__DEV__) {\n  Stack.displayName = \"Stack\"\n}\n\n/**\n * A view that arranges its children in a horizontal line.\n */\nexport const HStack = forwardRef<StackProps, \"div\">((props, ref) => (\n  <Stack align=\"center\" {...props} direction=\"row\" ref={ref} />\n))\n\nif (__DEV__) {\n  HStack.displayName = \"HStack\"\n}\n\n/**\n * A view that arranges its children in a vertical line.\n */\nexport const VStack = forwardRef<StackProps, \"div\">((props, ref) => (\n  <Stack align=\"center\" {...props} direction=\"column\" ref={ref} />\n))\n\nif (__DEV__) {\n  VStack.displayName = \"VStack\"\n}\n"],"sourceRoot":""}